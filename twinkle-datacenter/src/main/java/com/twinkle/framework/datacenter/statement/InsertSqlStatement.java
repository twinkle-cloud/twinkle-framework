package com.twinkle.framework.datacenter.statement;

import com.alibaba.fastjson2.JSONArray;
import com.alibaba.fastjson2.JSONObject;
import com.twinkle.framework.api.constant.ExceptionCode;
import com.twinkle.framework.api.context.AttributeInfo;
import com.twinkle.framework.api.context.NormalizedContext;
import com.twinkle.framework.api.exception.ConfigurationException;
import com.twinkle.framework.core.lang.*;
import com.twinkle.framework.datacenter.support.SnowflakeUidGenerator;
import com.twinkle.framework.datacenter.utils.JDBCUtil;
import com.twinkle.framework.struct.error.AttributeNotSetException;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.jdbc.core.SqlParameterValue;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Function: TODO ADD FUNCTION. <br/>
 * Reason:	 TODO ADD REASON. <br/>
 * Date:     10/16/19 10:01 PM<br/>
 *
 * @author chenxj
 * @see
 * @since JDK 1.8
 */
@Slf4j
public class InsertSqlStatement extends AbstractUpdateSqlStatement {
    private final static int PK_GENERATED_TYPE_ORACLE_SEQ = 1;
    private final static int PK_GENERATED_TYPE_AUTO_INCREMENT = 2;
    private final static int PK_GENERATED_TYPE_SNOWFLAKE = 3;
    private final static int PK_GENERATED_TYPE_UUID = 4;
    private final static int PK_GENERATED_TYPE_SIMPLE_UUID = 5;

    private final static Map<String, SnowflakeUidGenerator> ENTITY_IDGENERATOR_MAP;

    /**
     * The primary key attribute. This attribute is not mandatory, ONLY for ID retrieve.
     */
    private int primaryKeyAttrIndex;
    /**
     * The Primary Key attribute Info.
     */
    private AttributeInfo primaryKeyAttrInfo;
    /**
     * The primary Key Name in Table.
     */
    private String primaryKeyName;
    /**
     * The Field SQL Type for the primary key.
     * The value refers to: java.sql.Types.
     */
    private int primaryKeySqlType;
    /**
     * The primary key generated type.
     * If the Primary Key is set to be:
     * 1: - auto generated by DB sequence. The attribute should be a Long Attribute, and it's value will be
     * set to be the generated value.
     * And the Express should be
     * PrimaryKey: ID, UserIDAttr, 1, S_USER_ID
     * 2: - auto generated by auto-increment. Such as: MySQL, PgSQL, The attribute value should be a Long Attribute.
     * And the Express should be
     * PrimaryKey: ID, UserIDAttr, 2
     * 3: - auto generated by snowFlake. Could be used by all of the databases type. The attribute value should be a Long Attribute.
     * And the Express should be
     * PrimaryKey: ID, UserIDAttr, 3
     * 4: - auto generated by UUID. Could be used by all of the databases type. The attribute value should be a String Attribute.
     * And the Express should be
     * PrimaryKey: ID, UserIDAttr, 4
     * 5: - auto generated by UUID(Without '-'). Could be used by all of the databases type. The attribute value should be a String Attribute.
     * And the Express should be
     * PrimaryKey: ID, UserIDAttr, 5
     * If batchFlag = true, then the attribute should be ListAttribute(<LongAttribute>) or ListAttribute(<StringAttribute>);
     */
    private int pkGeneratedType = -1;
    /**
     * The primary key comment, ONLY used for Oracle Table's Sequence Name.
     */
    private String primaryKeyComment;

    static {
        ENTITY_IDGENERATOR_MAP = new ConcurrentHashMap<>();
    }

    @Override
    public void configure(JSONObject _conf) throws ConfigurationException {
        JSONArray tempPKArray = _conf.getJSONArray("PrimaryKey");
        if (!CollectionUtils.isEmpty(tempPKArray)) {
            this.parsePrimaryKey(tempPKArray);
        }
        super.configure(_conf);
        if (this.dbFieldArray == null || this.dbFieldArray.length == 0) {
            throw new ConfigurationException(ExceptionCode.LOGIC_CONF_REQUIRED_ATTR_MISSED, "The FieldMap is mandatory for Update SQL Statement Component.");
        }
    }

    /**
     * Parse the Primary key for the dest table.
     *
     * @param _conf
     * @throws ConfigurationException
     */
    private void parsePrimaryKey(JSONArray _conf) throws ConfigurationException {
        this.primaryKeyName = _conf.getString(0);
        this.primaryKeySqlType = _conf.getIntValue(1);
        String tempAttrName = _conf.getString(2);
        if (!tempAttrName.equals(NO_AVAILABLE)) {
            this.primaryKeyAttrInfo = this.primitiveAttributeSchema.getAttribute(tempAttrName);
            if (this.primaryKeyAttrInfo != null) {
                this.primaryKeyAttrIndex = this.primitiveAttributeSchema.getAttributeIndex(tempAttrName, _conf.toJSONString());
            } else {
                log.info("The Primary Key attribute [{}] is missed in Attribute Schema.", tempAttrName);
            }
        }
        this.pkGeneratedType = _conf.getIntValue(3);
        if (this.pkGeneratedType == 0 || this.pkGeneratedType > 5) {
            if (this.primaryKeyAttrIndex < 0) {
                throw new ConfigurationException(ExceptionCode.LOGIC_CONF_INVALID_EXPRESSION, "The PrimaryKey Value Generated Type [" + this.pkGeneratedType + "] is invalid.");
            }
        }
        int tempPrimitiveType = this.primaryKeyAttrInfo == null ? 0 : this.primaryKeyAttrInfo.getPrimitiveType();
        switch (this.pkGeneratedType) {
            case -1:
                log.info("The primary key attribute is not set, please ensure the SQL is valid for INSERT Dest table.");
                break;
            case PK_GENERATED_TYPE_AUTO_INCREMENT:
            case PK_GENERATED_TYPE_SNOWFLAKE:
                //For auto-increment type, No need add ID field in the sql.
                if (tempPrimitiveType > 0 && tempPrimitiveType != Attribute.LONG_TYPE
                        && tempPrimitiveType != Attribute.LIST_ATTRIBUTE_TYPE) {
                    throw new ConfigurationException(ExceptionCode.LOGIC_CONF_ATTR_NOT_ALLOWED, "The Primary Key Attribute should be LongAttribute or ListAttribute");
                }
                if (ENTITY_IDGENERATOR_MAP.get(this.destTableName) == null) {
                    long workerId = SnowflakeUidGenerator.getWorkerIdByIP(24);
                    ENTITY_IDGENERATOR_MAP.put(this.destTableName, new SnowflakeUidGenerator(workerId));
                }
                break;
            case PK_GENERATED_TYPE_ORACLE_SEQ:
                //For auto-increment type, No need add ID field in the sql.
                if (tempPrimitiveType > 0 && tempPrimitiveType != Attribute.LONG_TYPE
                        && tempPrimitiveType != Attribute.LIST_ATTRIBUTE_TYPE) {
                    throw new ConfigurationException(ExceptionCode.LOGIC_CONF_ATTR_NOT_ALLOWED, "The Primary Key Attribute should be LongAttribute or ListAttribute");
                }
                //Add Oracle ID Sequence Support.
                if (_conf.size() > 4) {
                    this.primaryKeyComment = _conf.getString(4);
                } else {
                    //Default sequence name is S_TableName.
                    this.primaryKeyComment = "S_" + this.destTableName;
                }
                break;
            case PK_GENERATED_TYPE_UUID:
            case PK_GENERATED_TYPE_SIMPLE_UUID:
                //For auto-increment type, No need add ID field in the sql.
                if (tempPrimitiveType > 0 && tempPrimitiveType != Attribute.STRING_TYPE
                        && tempPrimitiveType != Attribute.LIST_ATTRIBUTE_TYPE) {
                    throw new ConfigurationException(ExceptionCode.LOGIC_CONF_ATTR_NOT_ALLOWED, "The Primary Key Attribute should be StringAttribute or ListAttribute");
                }
                break;
        }
    }

    @Override
    protected String packSqlStatement() {
        StringBuffer tempBuffer = new StringBuffer("INSERT INTO ");
        tempBuffer.append(this.destTableName);
        tempBuffer.append(" (");
        StringBuffer tempValueBuffer = new StringBuffer();
        boolean addIdFlag = false;
        switch (this.pkGeneratedType) {
            case -1:
            case PK_GENERATED_TYPE_AUTO_INCREMENT:
                //For auto-increment type, No need add ID field in the sql.
                break;
            case PK_GENERATED_TYPE_ORACLE_SEQ:
                //Add Oracle ID Sequence Support.
                tempBuffer.append(this.primaryKeyName);
                tempValueBuffer.append(this.primaryKeyComment);
                tempValueBuffer.append(".nextval");
                addIdFlag = true;
                break;
            case PK_GENERATED_TYPE_SNOWFLAKE:
            case PK_GENERATED_TYPE_UUID:
            case PK_GENERATED_TYPE_SIMPLE_UUID:
                //For manual generated type, need add ID field in the sql.
                tempBuffer.append(this.primaryKeyName);
                //_ID to avoid duplication with the attribute's name
                tempValueBuffer.append(":_");
                tempValueBuffer.append(this.primaryKeyName);
                addIdFlag = true;
                break;
        }

        for (int i = 0; i < this.dbFieldArray.length; i++) {
            if (i == 0 && (!addIdFlag)) {
                tempBuffer.append(this.dbFieldArray[i]);
                tempValueBuffer.append(":");
                tempValueBuffer.append(this.attributeArray[i].getAttributeName());
            } else {
                tempBuffer.append(",");
                tempBuffer.append(this.dbFieldArray[i]);
                tempValueBuffer.append(", :");
                tempValueBuffer.append(this.attributeArray[i].getAttributeName());
            }
        }
        tempBuffer.append(") VALUES (");
        tempBuffer.append(tempValueBuffer.toString());
        tempBuffer.append(")");
        log.debug("The Insert original SQL is: {}", tempBuffer.toString());
        return tempBuffer.toString();
    }

    /**
     * Execute the statement in batch model.
     *
     * @param _context
     * @param _sqlSourceList
     */
    @Override
    protected void executeBatch(NormalizedContext _context, List<SqlParameterSource> _sqlSourceList) {
        int tempFromIndex = 0;
        int tempToIndex = BATCH_SIZE;

        while (tempFromIndex <= _sqlSourceList.size()) {
            if (tempToIndex > _sqlSourceList.size()) {
                tempToIndex = _sqlSourceList.size();
            }
            List<SqlParameterSource> tempSubList = _sqlSourceList.subList(tempFromIndex, tempToIndex);
            int[] tempResult = this.jdbcTemplate.batchUpdate(this.getPreparedSQL(), tempSubList.toArray(new SqlParameterSource[]{}));
            //Add the generated key into the key list.
            if (this.primaryKeyAttrIndex >= 0) {
                for (SqlParameterSource sourceItem : tempSubList) {
                    if (this.pkGeneratedType == PK_GENERATED_TYPE_SNOWFLAKE) {
                        this.addItemAttributeValue(_context, new LongAttribute((long) sourceItem.getValue("_" + this.primaryKeyName)));
                    } else if (this.pkGeneratedType == PK_GENERATED_TYPE_UUID ||
                            this.pkGeneratedType == PK_GENERATED_TYPE_SIMPLE_UUID) {
                        this.addItemAttributeValue(_context, new StringAttribute((String) sourceItem.getValue("_" + this.primaryKeyName)));
                    }
                }
            }
            log.debug("This batch [{}]->[{}] insert/update result is: {}", tempFromIndex, tempToIndex, tempResult);

            tempFromIndex = tempToIndex;
            tempToIndex += BATCH_SIZE;
        }
    }

    /**
     * Execute the statement with single row.
     *
     * @param _context
     * @param _sqlSource
     */
    @Override
    protected void executeSingle(NormalizedContext _context, SqlParameterSource _sqlSource) {
        if (this.pkGeneratedType == PK_GENERATED_TYPE_ORACLE_SEQ
                || this.pkGeneratedType == PK_GENERATED_TYPE_AUTO_INCREMENT) {
            KeyHolder tempHolder = new GeneratedKeyHolder();
            int tempResult = this.jdbcTemplate.update(this.getPreparedSQL(), _sqlSource, tempHolder, new String[]{this.primaryKeyName});
            if (tempResult > 0) {
                Number tempNumber = tempHolder.getKey();
                if (this.primaryKeyAttrIndex > -1) {
                    this.updateAttributeValue(_context, tempNumber.longValue());
                }
                log.debug("The generated ID for this statement is: {}", tempNumber.longValue());
            } else {
                log.info("There is no row updated this time.");
            }
        } else {
            int tempResult = this.jdbcTemplate.update(this.getPreparedSQL(), _sqlSource);
            // Update the generated ID into the AttributeId.
            if (this.pkGeneratedType > 0 && this.primaryKeyAttrIndex > -1) {
                this.updateAttributeValue(_context, _sqlSource.getValue("_" + this.primaryKeyName));
            }
            if (tempResult > 0) {
                log.debug("The row has been updated successfully.");
            } else {
                log.info("There is no row updated this time.");
            }
        }
    }

    /**
     * Update the value in context.
     *
     * @param _context
     * @param _value
     */
    private void updateAttributeValue(NormalizedContext _context, Object _value) {
        Attribute tempKeyAttr = _context.getAttribute(this.primaryKeyAttrIndex);
        if (tempKeyAttr == null) {
            tempKeyAttr = this.primitiveAttributeSchema.newAttributeInstance(this.primaryKeyAttrIndex);
        }
        tempKeyAttr.setValue(_value);
        _context.setAttribute(tempKeyAttr, this.primaryKeyAttrIndex);
    }

    /**
     * When batch model, add the item's key into the key list.
     *
     * @param _context
     * @param _value
     */
    private void addItemAttributeValue(NormalizedContext _context, Attribute _value) {
        ListAttribute tempKeyAttr = (ListAttribute) _context.getAttribute(this.primaryKeyAttrIndex);
        if (tempKeyAttr == null) {
            tempKeyAttr = (ListAttribute) this.primitiveAttributeSchema.newAttributeInstance(this.primaryKeyAttrIndex);
        }
        tempKeyAttr.add(_value);
        _context.setAttribute(tempKeyAttr, this.primaryKeyAttrIndex);
    }

    /**
     * Pack db fields' value array.
     *
     * @param _context
     * @param _rowIndex
     * @return
     */
    @Override
    protected SqlParameterSource packValuesArray(NormalizedContext _context, int _rowIndex) {
        MapSqlParameterSource tempSource = new MapSqlParameterSource();
        // Update the generated ID into the AttributeId.
        if (this.pkGeneratedType == PK_GENERATED_TYPE_SNOWFLAKE) {
            SnowflakeUidGenerator tempGenerator = ENTITY_IDGENERATOR_MAP.get(this.destTableName);
            long tempId = tempGenerator.getUID();
            tempSource.addValue("_" + this.primaryKeyName,
                    new SqlParameterValue(Types.VARCHAR, tempId));
        } else if (this.pkGeneratedType == PK_GENERATED_TYPE_UUID) {
            String tempId = UUIDAttribute.toString(UUIDAttribute.getNewUUID());
            tempSource.addValue("_" + this.primaryKeyName,
                    new SqlParameterValue(Types.VARCHAR, tempId));
        } else if (this.pkGeneratedType == PK_GENERATED_TYPE_UUID) {
            String tempId = UUIDAttribute.toStringWithoutDelimiter(UUIDAttribute.getNewUUID());
            tempSource.addValue("_" + this.primaryKeyName,
                    new SqlParameterValue(Types.VARCHAR, tempId));
        }

        for (int j = 0; j < this.attributeArray.length; j++) {
            Object tempObj = null;
            try {
                tempObj = this.attributeArray[j].getObjectValue(_context, this.dbFieldTypeArray[j], _rowIndex);
                if (tempObj == null && j < this.defaultValue.length) {
                    if (this.defaultValue[j] != null) {
                        tempObj = JDBCUtil.getSqlObjectDefaultValue(this.defaultValue[j], this.dbFieldTypeArray[j]);
                    }
                }
            } catch (AttributeNotSetException e) {
                log.warn("The Attribute has not been initialized, so use the default value.");
                if (this.defaultValue[j] != null && j < this.defaultValue.length) {
                    tempObj = JDBCUtil.getSqlObjectDefaultValue(this.defaultValue[j], this.dbFieldTypeArray[j]);
                }
            }
            tempSource.addValue(this.attributeArray[j].getAttributeName(), new SqlParameterValue(this.dbFieldTypeArray[j], tempObj));
        }
        return tempSource;
    }
}
